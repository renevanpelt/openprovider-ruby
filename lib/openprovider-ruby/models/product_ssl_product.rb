=begin
#REST API

#No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

OpenAPI spec version: 1.0.0-beta

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 3.0.30
=end

require 'date'

module OpenProvider
  class ProductSslProduct
    attr_accessor :brand_name

    attr_accessor :bypass_san

    attr_accessor :category

    # Average period of time between order creation and completion.
    attr_accessor :delivery_time

    attr_accessor :description

    attr_accessor :encryption

    attr_accessor :free_refund_period

    attr_accessor :free_reissue_period

    attr_accessor :id

    attr_accessor :included_domains_count

    attr_accessor :is_extended_validation_supported

    attr_accessor :is_idn_supported

    attr_accessor :is_mobile_supported

    attr_accessor :is_sgc_supported

    attr_accessor :is_wildcard_multidomain_supported

    attr_accessor :is_wildcard_supported

    attr_accessor :level_prices

    # Applies only to multi-domain certificates.
    attr_accessor :max_domains

    attr_accessor :max_period

    attr_accessor :name

    attr_accessor :number_of_domains

    attr_accessor :order_module

    attr_accessor :prices

    attr_accessor :root

    attr_accessor :sub_category

    attr_accessor :supported_software

    attr_accessor :validation_method

    attr_accessor :warranty

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'brand_name' => :'brand_name',
        :'bypass_san' => :'bypass_san',
        :'category' => :'category',
        :'delivery_time' => :'delivery_time',
        :'description' => :'description',
        :'encryption' => :'encryption',
        :'free_refund_period' => :'free_refund_period',
        :'free_reissue_period' => :'free_reissue_period',
        :'id' => :'id',
        :'included_domains_count' => :'included_domains_count',
        :'is_extended_validation_supported' => :'is_extended_validation_supported',
        :'is_idn_supported' => :'is_idn_supported',
        :'is_mobile_supported' => :'is_mobile_supported',
        :'is_sgc_supported' => :'is_sgc_supported',
        :'is_wildcard_multidomain_supported' => :'is_wildcard_multidomain_supported',
        :'is_wildcard_supported' => :'is_wildcard_supported',
        :'level_prices' => :'level_prices',
        :'max_domains' => :'max_domains',
        :'max_period' => :'max_period',
        :'name' => :'name',
        :'number_of_domains' => :'number_of_domains',
        :'order_module' => :'order_module',
        :'prices' => :'prices',
        :'root' => :'root',
        :'sub_category' => :'sub_category',
        :'supported_software' => :'supported_software',
        :'validation_method' => :'validation_method',
        :'warranty' => :'warranty'
      }
    end

    # Attribute type mapping.
    def self.openapi_types
      {
        :'brand_name' => :'Object',
        :'bypass_san' => :'Object',
        :'category' => :'Object',
        :'delivery_time' => :'Object',
        :'description' => :'Object',
        :'encryption' => :'Object',
        :'free_refund_period' => :'Object',
        :'free_reissue_period' => :'Object',
        :'id' => :'Object',
        :'included_domains_count' => :'Object',
        :'is_extended_validation_supported' => :'Object',
        :'is_idn_supported' => :'Object',
        :'is_mobile_supported' => :'Object',
        :'is_sgc_supported' => :'Object',
        :'is_wildcard_multidomain_supported' => :'Object',
        :'is_wildcard_supported' => :'Object',
        :'level_prices' => :'Object',
        :'max_domains' => :'Object',
        :'max_period' => :'Object',
        :'name' => :'Object',
        :'number_of_domains' => :'Object',
        :'order_module' => :'Object',
        :'prices' => :'Object',
        :'root' => :'Object',
        :'sub_category' => :'Object',
        :'supported_software' => :'Object',
        :'validation_method' => :'Object',
        :'warranty' => :'Object'
      }
    end

    # List of attributes with nullable: true
    def self.openapi_nullable
      Set.new([
      ])
    end
  
    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      if (!attributes.is_a?(Hash))
        fail ArgumentError, "The input argument (attributes) must be a hash in `OpenProvider::ProductSslProduct` initialize method"
      end

      # check to see if the attribute exists and convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h|
        if (!self.class.attribute_map.key?(k.to_sym))
          fail ArgumentError, "`#{k}` is not a valid attribute in `OpenProvider::ProductSslProduct`. Please check the name to make sure it's valid. List of attributes: " + self.class.attribute_map.keys.inspect
        end
        h[k.to_sym] = v
      }

      if attributes.key?(:'brand_name')
        self.brand_name = attributes[:'brand_name']
      end

      if attributes.key?(:'bypass_san')
        self.bypass_san = attributes[:'bypass_san']
      end

      if attributes.key?(:'category')
        self.category = attributes[:'category']
      end

      if attributes.key?(:'delivery_time')
        self.delivery_time = attributes[:'delivery_time']
      end

      if attributes.key?(:'description')
        self.description = attributes[:'description']
      end

      if attributes.key?(:'encryption')
        self.encryption = attributes[:'encryption']
      end

      if attributes.key?(:'free_refund_period')
        self.free_refund_period = attributes[:'free_refund_period']
      end

      if attributes.key?(:'free_reissue_period')
        self.free_reissue_period = attributes[:'free_reissue_period']
      end

      if attributes.key?(:'id')
        self.id = attributes[:'id']
      end

      if attributes.key?(:'included_domains_count')
        self.included_domains_count = attributes[:'included_domains_count']
      end

      if attributes.key?(:'is_extended_validation_supported')
        self.is_extended_validation_supported = attributes[:'is_extended_validation_supported']
      end

      if attributes.key?(:'is_idn_supported')
        self.is_idn_supported = attributes[:'is_idn_supported']
      end

      if attributes.key?(:'is_mobile_supported')
        self.is_mobile_supported = attributes[:'is_mobile_supported']
      end

      if attributes.key?(:'is_sgc_supported')
        self.is_sgc_supported = attributes[:'is_sgc_supported']
      end

      if attributes.key?(:'is_wildcard_multidomain_supported')
        self.is_wildcard_multidomain_supported = attributes[:'is_wildcard_multidomain_supported']
      end

      if attributes.key?(:'is_wildcard_supported')
        self.is_wildcard_supported = attributes[:'is_wildcard_supported']
      end

      if attributes.key?(:'level_prices')
        if (value = attributes[:'level_prices']).is_a?(Array)
          self.level_prices = value
        end
      end

      if attributes.key?(:'max_domains')
        self.max_domains = attributes[:'max_domains']
      end

      if attributes.key?(:'max_period')
        self.max_period = attributes[:'max_period']
      end

      if attributes.key?(:'name')
        self.name = attributes[:'name']
      end

      if attributes.key?(:'number_of_domains')
        self.number_of_domains = attributes[:'number_of_domains']
      end

      if attributes.key?(:'order_module')
        self.order_module = attributes[:'order_module']
      end

      if attributes.key?(:'prices')
        if (value = attributes[:'prices']).is_a?(Array)
          self.prices = value
        end
      end

      if attributes.key?(:'root')
        self.root = attributes[:'root']
      end

      if attributes.key?(:'sub_category')
        self.sub_category = attributes[:'sub_category']
      end

      if attributes.key?(:'supported_software')
        if (value = attributes[:'supported_software']).is_a?(Array)
          self.supported_software = value
        end
      end

      if attributes.key?(:'validation_method')
        self.validation_method = attributes[:'validation_method']
      end

      if attributes.key?(:'warranty')
        self.warranty = attributes[:'warranty']
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      true
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          brand_name == o.brand_name &&
          bypass_san == o.bypass_san &&
          category == o.category &&
          delivery_time == o.delivery_time &&
          description == o.description &&
          encryption == o.encryption &&
          free_refund_period == o.free_refund_period &&
          free_reissue_period == o.free_reissue_period &&
          id == o.id &&
          included_domains_count == o.included_domains_count &&
          is_extended_validation_supported == o.is_extended_validation_supported &&
          is_idn_supported == o.is_idn_supported &&
          is_mobile_supported == o.is_mobile_supported &&
          is_sgc_supported == o.is_sgc_supported &&
          is_wildcard_multidomain_supported == o.is_wildcard_multidomain_supported &&
          is_wildcard_supported == o.is_wildcard_supported &&
          level_prices == o.level_prices &&
          max_domains == o.max_domains &&
          max_period == o.max_period &&
          name == o.name &&
          number_of_domains == o.number_of_domains &&
          order_module == o.order_module &&
          prices == o.prices &&
          root == o.root &&
          sub_category == o.sub_category &&
          supported_software == o.supported_software &&
          validation_method == o.validation_method &&
          warranty == o.warranty
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [brand_name, bypass_san, category, delivery_time, description, encryption, free_refund_period, free_reissue_period, id, included_domains_count, is_extended_validation_supported, is_idn_supported, is_mobile_supported, is_sgc_supported, is_wildcard_multidomain_supported, is_wildcard_supported, level_prices, max_domains, max_period, name, number_of_domains, order_module, prices, root, sub_category, supported_software, validation_method, warranty].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      new.build_from_hash(attributes)
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.openapi_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        elsif attributes[self.class.attribute_map[key]].nil? && self.class.openapi_nullable.include?(key)
          self.send("#{key}=", nil)
        end
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :Boolean
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        OpenProvider.const_get(type).build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        if value.nil?
          is_nullable = self.class.openapi_nullable.include?(attr)
          next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
        end

        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end  end
end
