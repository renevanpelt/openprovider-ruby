=begin
#REST API

#No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

OpenAPI spec version: 1.0.0-beta

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 3.0.30
=end

require 'date'

module OpenProvider
  class TldTld
    attr_accessor :admin_handle_supported

    attr_accessor :billing_handle_enabled

    attr_accessor :billing_handle_supported

    attr_accessor :description

    attr_accessor :dnssec_algorithms

    attr_accessor :dnssec_allowed

    attr_accessor :dnssec_digests_allowed

    attr_accessor :dnssec_keys_allowed

    attr_accessor :dnssec_max_records_amount

    attr_accessor :domicile_available

    attr_accessor :is_auth_code_available

    attr_accessor :is_auth_code_changeable

    attr_accessor :is_auth_code_requested

    attr_accessor :is_private_whois_allowed

    attr_accessor :is_trade_auth_code_required

    attr_accessor :is_transfer_auth_code_required

    attr_accessor :level_prices

    attr_accessor :max_period

    attr_accessor :min_period

    attr_accessor :name

    attr_accessor :owner_handle_supported

    attr_accessor :prices

    attr_accessor :quarantine_period

    attr_accessor :renew_available

    attr_accessor :reseller_handle_enabled

    attr_accessor :reseller_handle_supported

    attr_accessor :restrictions

    attr_accessor :soft_quarantine_period

    attr_accessor :status

    attr_accessor :supported_application_mode

    attr_accessor :supported_idn_scripts

    attr_accessor :tech_handle_supported

    attr_accessor :trade_available

    attr_accessor :transfer_available

    attr_accessor :usage_count

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'admin_handle_supported' => :'admin_handle_supported',
        :'billing_handle_enabled' => :'billing_handle_enabled',
        :'billing_handle_supported' => :'billing_handle_supported',
        :'description' => :'description',
        :'dnssec_algorithms' => :'dnssec_algorithms',
        :'dnssec_allowed' => :'dnssec_allowed',
        :'dnssec_digests_allowed' => :'dnssec_digests_allowed',
        :'dnssec_keys_allowed' => :'dnssec_keys_allowed',
        :'dnssec_max_records_amount' => :'dnssec_max_records_amount',
        :'domicile_available' => :'domicile_available',
        :'is_auth_code_available' => :'is_auth_code_available',
        :'is_auth_code_changeable' => :'is_auth_code_changeable',
        :'is_auth_code_requested' => :'is_auth_code_requested',
        :'is_private_whois_allowed' => :'is_private_whois_allowed',
        :'is_trade_auth_code_required' => :'is_trade_auth_code_required',
        :'is_transfer_auth_code_required' => :'is_transfer_auth_code_required',
        :'level_prices' => :'level_prices',
        :'max_period' => :'max_period',
        :'min_period' => :'min_period',
        :'name' => :'name',
        :'owner_handle_supported' => :'owner_handle_supported',
        :'prices' => :'prices',
        :'quarantine_period' => :'quarantine_period',
        :'renew_available' => :'renew_available',
        :'reseller_handle_enabled' => :'reseller_handle_enabled',
        :'reseller_handle_supported' => :'reseller_handle_supported',
        :'restrictions' => :'restrictions',
        :'soft_quarantine_period' => :'soft_quarantine_period',
        :'status' => :'status',
        :'supported_application_mode' => :'supported_application_mode',
        :'supported_idn_scripts' => :'supported_idn_scripts',
        :'tech_handle_supported' => :'tech_handle_supported',
        :'trade_available' => :'trade_available',
        :'transfer_available' => :'transfer_available',
        :'usage_count' => :'usage_count'
      }
    end

    # Attribute type mapping.
    def self.openapi_types
      {
        :'admin_handle_supported' => :'Object',
        :'billing_handle_enabled' => :'Object',
        :'billing_handle_supported' => :'Object',
        :'description' => :'Object',
        :'dnssec_algorithms' => :'Object',
        :'dnssec_allowed' => :'Object',
        :'dnssec_digests_allowed' => :'Object',
        :'dnssec_keys_allowed' => :'Object',
        :'dnssec_max_records_amount' => :'Object',
        :'domicile_available' => :'Object',
        :'is_auth_code_available' => :'Object',
        :'is_auth_code_changeable' => :'Object',
        :'is_auth_code_requested' => :'Object',
        :'is_private_whois_allowed' => :'Object',
        :'is_trade_auth_code_required' => :'Object',
        :'is_transfer_auth_code_required' => :'Object',
        :'level_prices' => :'Object',
        :'max_period' => :'Object',
        :'min_period' => :'Object',
        :'name' => :'Object',
        :'owner_handle_supported' => :'Object',
        :'prices' => :'Object',
        :'quarantine_period' => :'Object',
        :'renew_available' => :'Object',
        :'reseller_handle_enabled' => :'Object',
        :'reseller_handle_supported' => :'Object',
        :'restrictions' => :'Object',
        :'soft_quarantine_period' => :'Object',
        :'status' => :'Object',
        :'supported_application_mode' => :'Object',
        :'supported_idn_scripts' => :'Object',
        :'tech_handle_supported' => :'Object',
        :'trade_available' => :'Object',
        :'transfer_available' => :'Object',
        :'usage_count' => :'Object'
      }
    end

    # List of attributes with nullable: true
    def self.openapi_nullable
      Set.new([
      ])
    end
  
    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      if (!attributes.is_a?(Hash))
        fail ArgumentError, "The input argument (attributes) must be a hash in `OpenProvider::TldTld` initialize method"
      end

      # check to see if the attribute exists and convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h|
        if (!self.class.attribute_map.key?(k.to_sym))
          fail ArgumentError, "`#{k}` is not a valid attribute in `OpenProvider::TldTld`. Please check the name to make sure it's valid. List of attributes: " + self.class.attribute_map.keys.inspect
        end
        h[k.to_sym] = v
      }

      if attributes.key?(:'admin_handle_supported')
        self.admin_handle_supported = attributes[:'admin_handle_supported']
      end

      if attributes.key?(:'billing_handle_enabled')
        self.billing_handle_enabled = attributes[:'billing_handle_enabled']
      end

      if attributes.key?(:'billing_handle_supported')
        self.billing_handle_supported = attributes[:'billing_handle_supported']
      end

      if attributes.key?(:'description')
        self.description = attributes[:'description']
      end

      if attributes.key?(:'dnssec_algorithms')
        if (value = attributes[:'dnssec_algorithms']).is_a?(Array)
          self.dnssec_algorithms = value
        end
      end

      if attributes.key?(:'dnssec_allowed')
        self.dnssec_allowed = attributes[:'dnssec_allowed']
      end

      if attributes.key?(:'dnssec_digests_allowed')
        self.dnssec_digests_allowed = attributes[:'dnssec_digests_allowed']
      end

      if attributes.key?(:'dnssec_keys_allowed')
        self.dnssec_keys_allowed = attributes[:'dnssec_keys_allowed']
      end

      if attributes.key?(:'dnssec_max_records_amount')
        self.dnssec_max_records_amount = attributes[:'dnssec_max_records_amount']
      end

      if attributes.key?(:'domicile_available')
        self.domicile_available = attributes[:'domicile_available']
      end

      if attributes.key?(:'is_auth_code_available')
        self.is_auth_code_available = attributes[:'is_auth_code_available']
      end

      if attributes.key?(:'is_auth_code_changeable')
        self.is_auth_code_changeable = attributes[:'is_auth_code_changeable']
      end

      if attributes.key?(:'is_auth_code_requested')
        self.is_auth_code_requested = attributes[:'is_auth_code_requested']
      end

      if attributes.key?(:'is_private_whois_allowed')
        self.is_private_whois_allowed = attributes[:'is_private_whois_allowed']
      end

      if attributes.key?(:'is_trade_auth_code_required')
        self.is_trade_auth_code_required = attributes[:'is_trade_auth_code_required']
      end

      if attributes.key?(:'is_transfer_auth_code_required')
        self.is_transfer_auth_code_required = attributes[:'is_transfer_auth_code_required']
      end

      if attributes.key?(:'level_prices')
        if (value = attributes[:'level_prices']).is_a?(Array)
          self.level_prices = value
        end
      end

      if attributes.key?(:'max_period')
        self.max_period = attributes[:'max_period']
      end

      if attributes.key?(:'min_period')
        self.min_period = attributes[:'min_period']
      end

      if attributes.key?(:'name')
        self.name = attributes[:'name']
      end

      if attributes.key?(:'owner_handle_supported')
        self.owner_handle_supported = attributes[:'owner_handle_supported']
      end

      if attributes.key?(:'prices')
        self.prices = attributes[:'prices']
      end

      if attributes.key?(:'quarantine_period')
        self.quarantine_period = attributes[:'quarantine_period']
      end

      if attributes.key?(:'renew_available')
        self.renew_available = attributes[:'renew_available']
      end

      if attributes.key?(:'reseller_handle_enabled')
        self.reseller_handle_enabled = attributes[:'reseller_handle_enabled']
      end

      if attributes.key?(:'reseller_handle_supported')
        self.reseller_handle_supported = attributes[:'reseller_handle_supported']
      end

      if attributes.key?(:'restrictions')
        if (value = attributes[:'restrictions']).is_a?(Array)
          self.restrictions = value
        end
      end

      if attributes.key?(:'soft_quarantine_period')
        self.soft_quarantine_period = attributes[:'soft_quarantine_period']
      end

      if attributes.key?(:'status')
        self.status = attributes[:'status']
      end

      if attributes.key?(:'supported_application_mode')
        if (value = attributes[:'supported_application_mode']).is_a?(Array)
          self.supported_application_mode = value
        end
      end

      if attributes.key?(:'supported_idn_scripts')
        if (value = attributes[:'supported_idn_scripts']).is_a?(Array)
          self.supported_idn_scripts = value
        end
      end

      if attributes.key?(:'tech_handle_supported')
        self.tech_handle_supported = attributes[:'tech_handle_supported']
      end

      if attributes.key?(:'trade_available')
        self.trade_available = attributes[:'trade_available']
      end

      if attributes.key?(:'transfer_available')
        self.transfer_available = attributes[:'transfer_available']
      end

      if attributes.key?(:'usage_count')
        self.usage_count = attributes[:'usage_count']
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      true
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          admin_handle_supported == o.admin_handle_supported &&
          billing_handle_enabled == o.billing_handle_enabled &&
          billing_handle_supported == o.billing_handle_supported &&
          description == o.description &&
          dnssec_algorithms == o.dnssec_algorithms &&
          dnssec_allowed == o.dnssec_allowed &&
          dnssec_digests_allowed == o.dnssec_digests_allowed &&
          dnssec_keys_allowed == o.dnssec_keys_allowed &&
          dnssec_max_records_amount == o.dnssec_max_records_amount &&
          domicile_available == o.domicile_available &&
          is_auth_code_available == o.is_auth_code_available &&
          is_auth_code_changeable == o.is_auth_code_changeable &&
          is_auth_code_requested == o.is_auth_code_requested &&
          is_private_whois_allowed == o.is_private_whois_allowed &&
          is_trade_auth_code_required == o.is_trade_auth_code_required &&
          is_transfer_auth_code_required == o.is_transfer_auth_code_required &&
          level_prices == o.level_prices &&
          max_period == o.max_period &&
          min_period == o.min_period &&
          name == o.name &&
          owner_handle_supported == o.owner_handle_supported &&
          prices == o.prices &&
          quarantine_period == o.quarantine_period &&
          renew_available == o.renew_available &&
          reseller_handle_enabled == o.reseller_handle_enabled &&
          reseller_handle_supported == o.reseller_handle_supported &&
          restrictions == o.restrictions &&
          soft_quarantine_period == o.soft_quarantine_period &&
          status == o.status &&
          supported_application_mode == o.supported_application_mode &&
          supported_idn_scripts == o.supported_idn_scripts &&
          tech_handle_supported == o.tech_handle_supported &&
          trade_available == o.trade_available &&
          transfer_available == o.transfer_available &&
          usage_count == o.usage_count
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [admin_handle_supported, billing_handle_enabled, billing_handle_supported, description, dnssec_algorithms, dnssec_allowed, dnssec_digests_allowed, dnssec_keys_allowed, dnssec_max_records_amount, domicile_available, is_auth_code_available, is_auth_code_changeable, is_auth_code_requested, is_private_whois_allowed, is_trade_auth_code_required, is_transfer_auth_code_required, level_prices, max_period, min_period, name, owner_handle_supported, prices, quarantine_period, renew_available, reseller_handle_enabled, reseller_handle_supported, restrictions, soft_quarantine_period, status, supported_application_mode, supported_idn_scripts, tech_handle_supported, trade_available, transfer_available, usage_count].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      new.build_from_hash(attributes)
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.openapi_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        elsif attributes[self.class.attribute_map[key]].nil? && self.class.openapi_nullable.include?(key)
          self.send("#{key}=", nil)
        end
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :Boolean
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        OpenProvider.const_get(type).build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        if value.nil?
          is_nullable = self.class.openapi_nullable.include?(attr)
          next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
        end

        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end  end
end
